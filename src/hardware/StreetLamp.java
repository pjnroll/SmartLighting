package hardware;

import exceptions.IntensityOutOfBoundException;
import helper.Intensity;

public class StreetLamp {
    private final static Intensity[] intensities = Intensity.values();

    private final static Intensity MIN_INTENSITY = Intensity.INTENSITY_0;     // Guard value
    private final static Intensity MAX_INTENSITY = Intensity.INTENSITY_6;   // Guard value

    private static int count = 0;
    private int id;
    private Intensity intensity;

    private StreetLamp next;    // Reference to the next Street Lamp
    private StreetLamp prev;    // Reference to the prev Street Lamp
    private int indexNext;      // Next Street Lamps' intensities' index
    private int indexPrev;      // Previous Street Lamps' intensities' index

    //TODO transorm it into a builder factory (o come cazzo si chiama) if you want
    public StreetLamp(Intensity intensity) throws IntensityOutOfBoundException {
        if (intensity.compareTo(MIN_INTENSITY) < 0 || intensity.compareTo(MAX_INTENSITY) > 0) {
            throw new IntensityOutOfBoundException(intensity);
        } else {
            this.intensity = intensity;
            id = count;
            count++;
        }
        this.prev = null;
        this.next = null;
    }

    public Intensity getIntensity() {
        return intensity;
    }

    /**
     * Prova di sendToNextStreetLamp()
     */
    private void sendToNextStreetLamp(Intensity intensity) {
        Street.currentSLNext = Street.currentSLNext.getNext();

        if (intensity.compareTo(intensities[3]) > 0) {
            Street.currentSLNext.setIntensity(intensity);
        }
        if (indexNext > 3 && Street.currentSLNext.getNext() != null) {
            indexNext--;
            sendToNextStreetLamp(intensities[indexNext]);
        }
    }


    /**
     * This method lets the current Street Lamp to communicate with the next one
     * @param intensity is a value generated by a combination of parameters, such as velocity
     */
    private void sendToNextStreetLampBackup(Intensity intensity) {
        // I get the reference to the next Street Lamp
        Street.currentSLNext = Street.currentSLNext.getNext();

        if (Street.currentSLNext.getNext() != null) {       // if there is another Street Lamp
            if (intensity.compareTo(Intensity.INTENSITY_3) >= 0) {  // if its intensity is higher-equal to 24
                Street.currentSLNext.setIntensity(intensity);           // I can set the intensity
                if (Street.currentSLNext.getNext() != null && indexNext > 0 && intensity.compareTo(Intensity.INTENSITY_3) > 0) {
                    if (indexNext > 0) {
                        indexNext--;
                        sendToNextStreetLamp(intensities[indexNext]);
                    }
                }
            }
        }
    }

    /**
     * This method lets the current Street Lamp to communicate with the previous one
     * @param intensity is a value generated by a combination of parameters, such as velocity
     */
    private void sendToPrevStreetLamp(Intensity intensity) {
        /*Street.currentSLPrev = Street.currentSLPrev.getPrev();
        System.out.println("Lampione:" + this + ", IntensitÃ :" + intensity);
        if (intensity.compareTo(Intensity.INTENSITY_3) >= 0) {
            Street.currentSLPrev.setIntensity(intensity);
            if (Street.currentSLPrev.getPrev() != null && indexPrev > 0 && intensity.compareTo(Intensity.INTENSITY_3) > 0) {
                if (indexPrev > 0) {
                    indexPrev--;
                    sendToPrevStreetLamp(intensities[indexPrev]);
                }
            }
        }*/

        Street.currentSLPrev = Street.currentSLPrev.getNext();

        if (intensity.compareTo(intensities[3]) > 0) {
            Street.currentSLPrev.setIntensity(intensity);
        }
        if (indexPrev > 3 && Street.currentSLPrev.getNext() != null) {
            indexNext--;
            sendToNextStreetLamp(intensities[indexPrev]);
        }

    }

    /**
     * Add a previous Street Lamp to the current one
     * @param p the Street Lamp to add
     */
    public void addPrevStreetLamp(StreetLamp p) {
        this.prev = p;
    }

    private StreetLamp getPrev() {
        return prev;
    }

    /**
     * Add a next Street Lamp to the current one
     * @param n the Street Lamp to add
     */
    public void addNextStreetLamp(StreetLamp n) {
        this.next = n;
    }

    private StreetLamp getNext() {
        return next;
    }

    private void setIntensity(Intensity intensity) {
        if (intensity.compareTo(MIN_INTENSITY) >= 0 && intensity.compareTo(MAX_INTENSITY) <= 0)
            this.intensity = intensity;
    }

    @Override
    public boolean equals(Object obj) {
        return obj instanceof StreetLamp && ((StreetLamp) obj).id == id;
    }

    @Override
    public String toString() {
        String s = "";
        s += id + ":" + intensity + " ";

        return s;
    }

    /**
     * This method is called when a sensor is activated (i.e. when it detect a car or a pedestrian)
     * It sets at the maximum intensity the current Street Lamps and the next two; it goes back to
     * the previous Street Lamps and goes on to the next ones
     */
    public void sensorDetected() {
        indexNext = indexPrev = 6;

        Street.currentSLPrev = this;
        Street.currentSLPrev.setIntensity(intensities[indexPrev]);
        assert Street.currentSLPrev.getPrev() != null && indexPrev > 0;
        indexPrev--;
        sendToPrevStreetLamp(intensities[indexPrev]);


        Street.currentSLNext = this;
        // Turn on 3 street lamps
        Street.currentSLNext.setIntensity(intensities[indexPrev]);
        for (int i = 0; i < 2 && Street.currentSLNext.getNext() != null; i++) {
            Street.currentSLNext = Street.currentSLNext.getNext();
            Street.currentSLNext.setIntensity(intensities[indexPrev]);
        }
        assert Street.currentSLNext.getNext() != null && indexNext > 0;
        indexNext--;
        sendToNextStreetLamp(intensities[indexPrev]);
    }
}